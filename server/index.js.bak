// server/index.js
import express from "express";
import cors from "cors";
import "dotenv/config";
import bcrypt from "bcryptjs";
import crypto from "crypto";
import rateLimit from "express-rate-limit";

import session from "express-session";
import FileStoreFactory from "session-file-store";

import pkg from "@prisma/client";
const { PrismaClient } = pkg;

import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";

// ------------------------------------
// App
// ------------------------------------
const app = express();
const API = "/api";

/* ---------------------------
   Middleware
---------------------------- */
app.use(express.json({ limit: "5mb" }));

// CORS
const CLIENT_ORIGIN = (process.env.CLIENT_ORIGIN || "http://localhost:5173").trim();

function isAllowedOrigin(origin) {
  if (!origin) return true; // curl/postman
  if (origin === CLIENT_ORIGIN) return true;

  // local dev fallbacks
  if (origin === "http://localhost:5173") return true;
  if (origin === "http://127.0.0.1:5173") return true;

  // custom domains
  if (origin === "https://balanceary.app") return true;
  if (origin === "https://www.balanceary.app") return true;

  // vercel previews
  if (/^https:\/\/.*\.vercel\.app$/.test(origin)) return true;

  return false;
}

app.use(
  cors({
    origin: (origin, cb) => {
      if (isAllowedOrigin(origin)) return cb(null, true);
      return cb(new Error(`CORS blocked: ${origin}`));
    },
    credentials: true,
  })
);

// Rate limit
app.use(
  rateLimit({
    windowMs: 60 * 1000,
    max: 300,
    standardHeaders: true,
    legacyHeaders: false,
  })
);

/* ---------------------------
   Prisma (Prisma 7 + SQLite adapter)
---------------------------- */
if (!process.env.DATABASE_URL) {
  console.warn("⚠️ DATABASE_URL is not set. Example: file:./dev.db");
}

const adapter = new PrismaBetterSqlite3({
  url: process.env.DATABASE_URL,
});
const prisma = new PrismaClient({ adapter });

/* ---------------------------
   Sessions (Persistent file store)
   - Fixes Node 24 ESM require-cycle issue
---------------------------- */
const FileStore = FileStoreFactory(session);

// Render persistent disk: /var/data
const sessionsDir = process.env.RENDER === "true" ? "/var/data/sessions" : "./sessions";

app.set("trust proxy", 1);

app.use(
  session({
    name: "sid",
    store: new FileStore({
      path: sessionsDir,
      retries: 0,
      ttl: 60 * 60 * 24 * 30, // 30 days
    }),
    secret: process.env.SESSION_SECRET || crypto.randomBytes(32).toString("hex"),
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      sameSite: "lax",
      secure: process.env.NODE_ENV === "production",
      maxAge: 1000 * 60 * 60 * 24 * 30, // 30 days
    },
  })
);

/* ---------------------------
   Helpers
---------------------------- */
function requireAuth(req, res, next) {
  if (!req.session?.userId) return res.status(401).json({ error: "Unauthorized" });
  next();
}

function toStr(v) {
  return v == null ? "" : String(v).trim();
}

function startOfDay(d) {
  const x = new Date(d);
  x.setHours(0, 0, 0, 0);
  return x;
}
function addDays(d, n) {
  const x = new Date(d);
  x.setDate(x.getDate() + n);
  return x;
}
function isoDate(d) {
  return startOfDay(d).toISOString().slice(0, 10);
}
function parseIsoDate(yyyyMmDd) {
  const [y, m, d] = String(yyyyMmDd || "")
    .split("-")
    .map((x) => parseInt(x, 10));
  if (!y || !m || !d) return null;
  const dt = new Date(y, m - 1, d);
  dt.setHours(0, 0, 0, 0);
  return dt;
}
function addMonths(date, n) {
  const x = new Date(date);
  x.setMonth(x.getMonth() + n);
  x.setHours(0, 0, 0, 0);
  return x;
}
function addYears(date, n) {
  const x = new Date(date);
  x.setFullYear(x.getFullYear() + n);
  x.setHours(0, 0, 0, 0);
  return x;
}

function normalizeDateToIso(s) {
  const str = toStr(s);
  if (!str) return "";
  if (/^\d{4}-\d{2}-\d{2}$/.test(str)) return str;

  const m = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
  if (!m) return "";
  const mm = m[1].padStart(2, "0");
  const dd = m[2].padStart(2, "0");
  const yyyy = m[3].length === 2 ? `20${m[3]}` : m[3];
  return `${yyyy}-${mm}-${dd}`;
}

function makeImportHash(userId, date, merchant, amount, account) {
  const raw = `${userId}|${date}|${merchant}|${amount}|${account}`;
  return crypto.createHash("sha1").update(raw).digest("hex");
}

/* ---------------------------
   Merchant -> Category rules (merchant only)
---------------------------- */
function normalizeForMatch(s) {
  return String(s || "")
    .toLowerCase()
    .trim()
    .replace(/\s+/g, " ")
    .replace(/[^a-z0-9 ]/g, "");
}

function sortRulesBestFirst(rules) {
  return (rules || [])
    .slice()
    .sort((a, b) => String(b.match || "").length - String(a.match || "").length);
}

function categoryFromRules(rules, merchantRaw) {
  const merchant = normalizeForMatch(merchantRaw);
  if (!merchant) return null;

  for (const r of rules) {
    const needle = normalizeForMatch(r.match);
    if (!needle) continue;
    if (merchant.includes(needle)) return String(r.category || "");
  }
  return null;
}

async function autoCategoryForMerchant(userId, merchant) {
  const rulesRaw = await prisma.rule.findMany({
    where: { userId },
    select: { match: true, category: true },
  });
  const rules = sortRulesBestFirst(rulesRaw);
  return categoryFromRules(rules, merchant) || "Uncategorized";
}

/* ---------------------------
   Recurring helpers
---------------------------- */
function monthlyOccurrencesWithinDayOfMonth(dayOfMonth, from, to) {
  const dom = Math.max(1, Math.min(28, Number(dayOfMonth || 1)));
  const start = startOfDay(from);
  const end = startOfDay(to);

  let cursor = new Date(start.getFullYear(), start.getMonth(), 1);
  cursor.setHours(0, 0, 0, 0);

  const out = [];
  while (cursor <= end) {
    const occurrence = new Date(cursor.getFullYear(), cursor.getMonth(), dom);
    occurrence.setHours(0, 0, 0, 0);
    if (occurrence >= start && occurrence <= end) out.push(isoDate(occurrence));
    cursor = addMonths(cursor, 1);
  }
  return out;
}

function cadenceNextDateOccurrences(nextDateStr, cadence, from, to) {
  const start = startOfDay(from);
  const end = startOfDay(to);

  const first = parseIsoDate(nextDateStr);
  if (!first) return [];

  let cur = startOfDay(first);
  const out = [];

  while (cur < start) {
    if (cadence === "weekly") cur = addDays(cur, 7);
    else if (cadence === "monthly") cur = addMonths(cur, 1);
    else if (cadence === "quarterly") cur = addMonths(cur, 3);
    else if (cadence === "yearly") cur = addYears(cur, 1);
    else return [];
  }

  while (cur <= end) {
    out.push(isoDate(cur));
    if (cadence === "weekly") cur = addDays(cur, 7);
    else if (cadence === "monthly") cur = addMonths(cur, 1);
    else if (cadence === "quarterly") cur = addMonths(cur, 3);
    else if (cadence === "yearly") cur = addYears(cur, 1);
    else break;
  }

  return out;
}

/* ---------------------------
   Health
---------------------------- */
app.get(`${API}/health`, (req, res) => {
  res.json({ ok: true, time: new Date().toISOString() });
});

/* ---------------------------
   Auth
---------------------------- */
app.post(`${API}/auth/register`, async (req, res) => {
  try {
    const { email, password } = req.body || {};
    if (!email || !password) return res.status(400).json({ error: "email and password required" });

    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) return res.status(400).json({ error: "Email already in use" });

    const hash = await bcrypt.hash(password, 12);

    const user = await prisma.user.create({
      data: { email, passwordHash: hash },
      select: { id: true, email: true, createdAt: true },
    });

    req.session.userId = user.id;
    res.json({ user });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

app.post(`${API}/auth/login`, async (req, res) => {
  try {
    const { email, password } = req.body || {};
    if (!email || !password) return res.status(400).json({ error: "email and password required" });

    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) return res.status(400).json({ error: "Invalid credentials" });

    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(400).json({ error: "Invalid credentials" });

    req.session.userId = user.id;
    res.json({ user: { id: user.id, email: user.email } });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

app.post(`${API}/auth/logout`, (req, res) => {
  req.session?.destroy(() => res.json({ ok: true }));
});

app.get(`${API}/auth/me`, async (req, res) => {
  try {
    const userId = req.session?.userId;
    if (!userId) return res.json({ user: null });

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, email: true, createdAt: true },
    });

    res.json({ user });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

/* ---------------------------
   CSV Import (manual dedupe)
---------------------------- */
app.post(`${API}/import/csv/dry-run`, requireAuth, async (req, res) => {
  try {
    const userId = req.session.userId;
    const { month, rows } = req.body || {};

    if (!month || !/^\d{4}-\d{2}$/.test(String(month))) {
      return res.status(400).json({ error: "month must be YYYY-MM" });
    }
    if (!Array.isArray(rows) || rows.length === 0) {
      return res.status(400).json({ error: "rows array required" });
    }

    const preview = [];
    let invalid = 0;

    for (const r of rows) {
      const date = normalizeDateToIso(r.date || r.Date || r["Posting Date"] || r["Transaction Date"]);
      const merchant = toStr(r.merchant || r.Description || r.description || r.Merchant || r.Payee || r.Name);
      const account = toStr(r.account || r.Account) || "Chequing";
      const amount = Number(r.amount ?? r.Amount ?? r.CAD ?? r.Value);

      if (!date || !date.startsWith(month) || !Number.isFinite(amount) || !merchant) {
        invalid++;
        continue;
      }

      const category = await autoCategoryForMerchant(userId, merchant);
      preview.push({ date, merchant, amount, account, category, note: toStr(r.note || r.Note) });
      if (preview.length >= 50) break;
    }

    res.json({ ok: true, previewCount: preview.length, invalid, preview });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

app.post(`${API}/import/csv`, requireAuth, async (req, res) => {
  try {
    const userId = req.session.userId;
    const { rows, source } = req.body || {};

    if (!Array.isArray(rows) || rows.length === 0) {
      return res.status(400).json({ error: "rows array required" });
    }

    const toInsert = [];
    let skipped = 0;

    for (const r of rows) {
      const date = normalizeDateToIso(r.date || r.Date || r["Posting Date"] || r["Transaction Date"]);
      const merchant = toStr(r.merchant || r.Description || r.description || r.Merchant || r.Payee || r.Name);
      const account = toStr(r.account || r.Account) || "Chequing";
      const note = toStr(r.note || r.Note);
      const amount = Number(r.amount ?? r.Amount ?? r.CAD ?? r.Value);

      if (!date || !merchant || !Number.isFinite(amount)) {
        skipped++;
        continue;
      }

      const category = await autoCategoryForMerchant(userId, merchant);
      const importHash = makeImportHash(userId, date, merchant, amount, account);

      toInsert.push({
        userId,
        date,
        amount,
        category,
        merchant,
        account,
        note,
        source: toStr(source) || "csv",
        importHash,
      });
    }

    if (toInsert.length === 0) {
      return res.json({ inserted: 0, skipped });
    }

    const hashes = toInsert.map((r) => r.importHash);

    const existing = await prisma.transaction.findMany({
      where: { userId, importHash: { in: hashes } },
      select: { importHash: true },
    });

    const existingSet = new Set(existing.map((x) => x.importHash));
    const newRows = toInsert.filter((r) => !existingSet.has(r.importHash));

    let inserted = 0;
    if (newRows.length) {
      const result = await prisma.transaction.createMany({ data: newRows });
      inserted = Number(result?.count ?? 0);
    }

    const deduped = toInsert.length - newRows.length;
    return res.json({ inserted, skipped: skipped + deduped });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: "Server error" });
  }
});

/* ---------------------------
   Transactions
---------------------------- */
app.get(`${API}/transactions`, requireAuth, async (req, res) => {
  try {
    const userId = req.session.userId;
    const items = await prisma.transaction.findMany({
      where: { userId },
      orderBy: [{ date: "desc" }, { createdAt: "desc" }],
    });
    res.json({ transactions: items });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

app.post(`${API}/transactions`, requireAuth, async (req, res) => {
  try {
    const userId = req.session.userId;
    const { date, amount, category, merchant, account, note } = req.body || {};
    if (!date || amount == null) return res.status(400).json({ error: "date and amount required" });

    let finalCategory = String(category || "");
    if (!finalCategory || finalCategory.toLowerCase() === "uncategorized") {
      finalCategory = await autoCategoryForMerchant(userId, merchant);
    }

    const created = await prisma.transaction.create({
      data: {
        userId,
        date: String(date),
        amount: Number(amount),
        category: finalCategory || "Uncategorized",
        merchant: String(merchant || ""),
        account: String(account || ""),
        note: String(note || ""),
        source: "manual",
      },
    });

    res.json(created);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

/* ---------------------------
   Recurring generate (manual dedupe)
---------------------------- */
app.post(`${API}/recurring/generate`, requireAuth, async (req, res) => {
  try {
    const userId = req.session.userId;
    const { month } = req.body || {};
    if (!month || !/^\d{4}-\d{2}$/.test(String(month))) {
      return res.status(400).json({ error: "month must be YYYY-MM" });
    }

    const items = await prisma.recurring.findMany({
      where: { userId, isActive: true },
    });

    const rows = items.map((r) => {
      const dd = String(Math.max(1, Math.min(28, r.dayOfMonth))).padStart(2, "0");
      const date = `${month}-${dd}`;
      const importHash = `recurring:${r.id}:${date}`;
      return {
        userId,
        date,
        amount: Number(r.amount),
        category: r.category || "",
        merchant: r.merchant || "",
        account: r.account || "",
        note: r.note || "",
        source: "recurring",
        recurringId: r.id,
        importHash,
      };
    });

    if (!rows.length) return res.json({ ok: true, generated: 0 });

    const hashes = rows.map((r) => r.importHash);
    const existing = await prisma.transaction.findMany({
      where: { userId, importHash: { in: hashes } },
      select: { importHash: true },
    });

    const existingSet = new Set(existing.map((x) => x.importHash));
    const newRows = rows.filter((r) => !existingSet.has(r.importHash));

    if (newRows.length) {
      await prisma.transaction.createMany({ data: newRows });
    }

    res.json({ ok: true, generated: newRows.length });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Server error" });
  }
});

/* ---------------------------
   Start server
---------------------------- */
const PORT = process.env.PORT || 4000;

app.listen(PORT, () => {
  console.log(`✅ API running on http://localhost:${PORT}`);
  console.log(`✅ CLIENT_ORIGIN = ${CLIENT_ORIGIN}`);

  if (CLIENT_ORIGIN.includes('"') || CLIENT_ORIGIN.includes("\n")) {
    console.warn("⚠️ Your CLIENT_ORIGIN env looks malformed. Use: CLIENT_ORIGIN=http://localhost:5173");
  }
});
